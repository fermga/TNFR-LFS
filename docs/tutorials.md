# Tutorials

This section walks through the full TNFR × LFS workflow, from capturing a
baseline to producing an explainable setup report.  The examples assume
you installed the project in editable mode using ``pip install -e .`` and
that Live for Speed has been prepared with the recommended telemetry
configuration.

## 0. Enable telemetry in ``cfg.txt``

Locate the simulator ``cfg.txt`` file and adjust the streaming blocks:

```text
OutSim Mode 1
OutSim IP 127.0.0.1
OutSim Port 4123

OutGauge Mode 1
OutGauge IP 127.0.0.1
OutGauge Port 3000

InSim IP 127.0.0.1
InSim Port 29999
```

You can mirror the same values from the in-game console using ``/outsim 1 127.0.0.1 4123``,
``/outgauge 1 127.0.0.1 3000`` and ``/insim 29999``.  Afterwards execute

```bash
tnfr-lfs diagnose /ruta/a/LFS/cfg.txt
```

to validate that OutSim/OutGauge are enabled and that the UDP ports are available before
capturing telemetry.

## 0 bis. Visualise the live HUD

With the telemetry broadcasters active you can display the ΔNFR HUD directly
inside Live for Speed:

```bash
tnfr-lfs osd --host 127.0.0.1 --outsim-port 4123 --outgauge-port 3000 --insim-port 29999
```

Click on the overlay button to rotate through the three pages: (A) active
corner and dissonance breakdown with the ΔNFR gauge, ``ν_f~`` waveform and
coherence bar, (B) nodal |ΔNFR↓| contributions and modal resonance enriched with
the same coherence widgets, (C) setup hints aligned with the current phase and
the ``Si plan`` trace.  Use the ``--layout-*`` overrides if you need to move the
40×16 button to a different area of the HUD.

## 1. Capture a baseline

```bash
tnfr-lfs baseline stint.jsonl --duration 45 --outsim-port 4123 --outgauge-port 3000
```

The command records live telemetry for 45 seconds, combining the OutSim
and OutGauge streams exposed by the simulator.  Use ``--simulate`` to
ingest a prerecorded CSV file when live capture is not available.

## 2. Analyse the telemetry

```bash
tnfr-lfs analyze stint.jsonl --export json > analyze.json
```

This step computes the ΔNFR/Sense Index series using the core operators
and stores the payload as a JSON document.  Switch the exporter to ``csv``
to obtain a flat table with timestamped values.

## 3. Generate suggestions

```bash
tnfr-lfs suggest stint.jsonl --car-model generic_gt --track spa --export json > suggestions.json
```

The recommendation engine evaluates the telemetry against the thresholds
defined for the selected car model and track.  The resulting payload
contains rule identifiers, rationales, and expected effects.

## 4. Build a report

```bash
tnfr-lfs report stint.jsonl --target-delta 0.5 --target-si 0.8 --export markdown > report.md
```

Reports orchestrate the operators, highlight ΔNFR gaps relative to the
requested objectives, and produce a Markdown summary ready for sharing.
The command also writes the coherence map, operator trajectories and ΔNFR
bifurcation artefacts under ``out/<baseline>/``.  Select the preferred
representation with ``--report-format``: ``json`` for machine processing,
``markdown`` for notebooks, or ``visual`` to generate compact ASCII
sketches that can be pasted into chat tools.

## 5. Create a setup plan (optional)

```bash
tnfr-lfs write-set stint.jsonl --car-model generic_gt --session FP1 --export markdown > setup.md
```

The planner runs the optimisation-aware search module to propose setup
deltas while embedding the explanations generated by the recommendation
engine.  The Markdown exporter merges duplicated rationales so the final
document can be handed directly to race engineers.

## Python API quick start

Each step of the CLI flow is also exposed through the Python API:

```python
from tnfr_lfs.acquisition import OutSimClient
from tnfr_lfs.core.epi import EPIExtractor
from tnfr_lfs.core.segmentation import segment_microsectors
from tnfr_lfs.recommender import RecommendationEngine, SetupPlanner
from tnfr_lfs.exporters.setup_plan import SetupPlan, SetupChange

records = OutSimClient().ingest("stint.csv")
extractor = EPIExtractor()
bundles = extractor.extract(records)
microsectors = segment_microsectors(records, bundles)

engine = RecommendationEngine()
recommendations = engine.generate(bundles)

planner = SetupPlanner()
plan = planner.plan(bundles, microsectors=microsectors, car_model="generic_gt")

setup_payload = {
    "setup_plan": SetupPlan(
        car_model="generic_gt",
        session="FP1",
        changes=[
            SetupChange(
                parameter="rear_wing_angle",
                delta=-1.0,
                rationale=recommendations[0].rationale,
                expected_effect=recommendations[0].expected_effect,
            )
        ],
        rationales=[rec.rationale for rec in recommendations],
        expected_effects=[rec.expected_effect for rec in recommendations],
        sensitivities=plan.sensitivities,
        phase_sensitivities=plan.phase_sensitivities,
    )
}
```

The snippet captures telemetry from a CSV file, extracts EPI bundles,
derives microsectors, and combines optimisation with explainable
recommendations to build a setup plan ready for export.  The
``sensitivities`` and ``phase_sensitivities`` mappings expose the
empirical Jacobian gathered during the optimisation, enabling
downstream tooling to reuse the ΔSi/Δp and Δ∫|ΔNFR|/Δp gradients.
