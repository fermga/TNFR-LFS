# Tutorials

This section walks through the full TNFR × LFS workflow, from capturing a
baseline to producing an explainable setup report.  The examples assume
you installed the project in editable mode using ``pip install -e .`` and
that Live for Speed has been prepared with the recommended telemetry
configuration.

## 0. Enable telemetry in ``cfg.txt``

Locate the simulator ``cfg.txt`` file and adjust the streaming blocks:

```text
OutSim Mode 1
OutSim IP 127.0.0.1
OutSim Port 4123

OutGauge Mode 1
OutGauge IP 127.0.0.1
OutGauge Port 3000

InSim IP 127.0.0.1
InSim Port 29999
```

You can mirror the same values from the in-game console using ``/outsim 1 127.0.0.1 4123``,
``/outgauge 1 127.0.0.1 3000`` and ``/insim 29999``.  Afterwards execute

```bash
tnfr-lfs diagnose /ruta/a/LFS/cfg.txt
```

to validate that OutSim/OutGauge are enabled and that the UDP ports are available before
capturing telemetry.

## 0 bis. Visualise the live HUD

With the telemetry broadcasters active you can display the ΔNFR HUD directly
inside Live for Speed:

```bash
tnfr-lfs osd --host 127.0.0.1 --outsim-port 4123 --outgauge-port 3000 --insim-port 29999
```

Click on the overlay button to rotate through the three pages: (A) active
corner and dissonance breakdown with the ΔNFR gauge, ``ν_f~`` waveform and
coherence bar, (B) nodal |ΔNFR↓| contributions and modal resonance enriched with
the same coherence widgets, (C) setup hints aligned with the current phase and
the ``Si plan`` trace.  Use the ``--layout-*`` overrides if you need to move the
40×16 button to a different area of the HUD.

Consult the [setup equivalence guide](setup_equivalences.md) to interpret how
the HUD surfaces the nodal projections `∇NFR∥`/`∇NFR⊥`, together with `ν_f` and
`C(t)`, for each subsystem before tweaking the setup.  Esa guía aclara cuándo
conviene consultar los canales `Fz`/`ΔFz` originales si el ajuste depende de
cargas absolutas.

## 1. Capture a baseline

```bash
tnfr-lfs baseline stint.jsonl --duration 45 --outsim-port 4123 --outgauge-port 3000
```

The command records live telemetry for 45 seconds, combining the OutSim
and OutGauge streams exposed by the simulator.  Use ``--simulate`` to
ingest a prerecorded CSV file when live capture is not available.

## 2. Analyse the telemetry

```bash
tnfr-lfs analyze stint.jsonl --export json > analyze.json
```

This step computes the ΔNFR/Sense Index series using the core operators
and stores the payload as a JSON document.  Switch the exporter to ``csv``
to obtain a flat table with timestamped values.

## 3. Generate suggestions

```bash
tnfr-lfs suggest stint.jsonl --car-model FZR --track AS5 --export json > suggestions.json
```

The recommendation engine evaluates the telemetry against the thresholds
defined for the selected car model and track.  The resulting payload
contains rule identifiers, rationales, and expected effects.

Cross-check those insights with the [equivalence tables](setup_equivalences.md)
to translate each metric (proyecciones `∇NFR∥`/`∇NFR⊥`, `ν_f`, `C(t)`) into
actionable setup changes aligned with the TNFR plan.  Las tablas también te
recuerdan cuándo una recomendación basada en `∇NFR⊥` debe validarse con las
cargas `Fz`/`ΔFz` si el ajuste depende del apoyo absoluto disponible.

## 4. Build a report

```bash
tnfr-lfs report stint.jsonl --target-delta 0.5 --target-si 0.8 --export markdown > report.md
```

Reports orchestrate the operators, highlight ΔNFR gaps relative to the
requested objectives, and produce a Markdown summary ready for sharing.
The command also writes the coherence map, operator trajectories and ΔNFR
bifurcation artefacts under ``out/<baseline>/``.  Select the preferred
representation with ``--report-format``: ``json`` for machine processing,
``markdown`` for notebooks, or ``visual`` to generate compact ASCII
sketches that can be pasted into chat tools.

## 5. Create a setup plan (optional)

```bash
tnfr-lfs write-set stint.jsonl --car-model FZR --session FP1 --export markdown > setup.md
```

The planner runs the optimisation-aware search module to propose setup
deltas while embedding the explanations generated by the recommendation
engine.  The Markdown exporter merges duplicated rationales so the final
document can be handed directly to race engineers.

## Métrica ↔ operador estructural ↔ palanca

| Métrica TNFR | Operador estructural | Palanca primaria | Playbook y guías |
| --- | --- | --- | --- |
| `∇NFR⊥` (proyección nodal lateral) | `recursivity_operator` mantiene la memoria térmica/estilística por microsector y filtra las contribuciones ΔNFR para detectar picos persistentes antes de cerrar un stint.【F:tnfr_lfs/core/operators.py†L475-L646】 | El controlador de balance de neumáticos convierte esas desviaciones relativas en ΔP/Δcamber y sesgos por rueda.  Cuando la corrección requiera cuantificar la carga absoluta, cruza la recomendación con los canales `Fz`/`ΔFz` antes de modificar barras, bias o presiones.【F:tnfr_lfs/core/operators.py†L733-L831】【F:docs/setup_equivalences.md†L61-L152】 | Consulta el [playbook TNFR](../tnfr_lfs/data/playbooks/tnfr_playbook.toml) para priorizar acciones cuando el informe muestre alertas de carga.【F:tnfr_lfs/io/playbook.py†L35-L64】 |
| `ν_f` | `mutation_operator` vigila la entropía estructural y la deriva de estilo para mutar el arquetipo y restablecer la frecuencia natural objetivo por fase.【F:tnfr_lfs/core/operators.py†L834-L940】 | Ajusta muelles, barras y geometría según las recomendaciones vinculadas a `ν_f` en la tabla de equivalencias (rigidez, toe) cuando el HUD/CLI indique "muy baja"/"muy alta".【F:docs/setup_equivalences.md†L87-L152】 | El playbook refuerza estas acciones con recordatorios por microsector y fase.【F:tnfr_lfs/io/playbook.py†L35-L64】 |
| `C(t)` | La misma memoria recursiva expone la traza de coherencia y alimenta las métricas de robustez; los exportadores la usan para reconstruir acoplamientos nodales y pérdida de coherencia.【F:tnfr_lfs/core/operators.py†L475-L646】【F:tnfr_lfs/exporters/report_extended.py†L156-L179】 | Modula amortiguadores, camber y controles electrónicos para recuperar coherencia cuando los informes destaquen decoherencia o ABS agresivo.【F:docs/setup_equivalences.md†L91-L140】 | Cruza las banderas del playbook para validar qué subsistema atacar primero.【F:tnfr_lfs/io/playbook.py†L35-L64】 |

## 6. Validar robustez del setup

Tras obtener `report.md`, genera un informe navegable con el exportador extendido para revisar la variabilidad y los acoplamientos estructurales:

```bash
tnfr-lfs report stint.jsonl --target-delta 0.5 --target-si 0.8 --export html_ext > report.html
```

El HTML resultante incluye secciones de robustez con variabilidad por microsector, traza recursiva y acoplamientos nodales que ayudan a identificar configuraciones frágiles antes de iterar el setup.【F:tnfr_lfs/exporters/report_extended.py†L156-L179】【F:tnfr_lfs/exporters/report_extended.py†L290-L324】 Cuando dichas tablas señalen microsectores inestables, consulta la tabla de operadores anterior y aplica las palancas recomendadas en el playbook TNFR para reforzar el área comprometida.【F:tnfr_lfs/io/playbook.py†L35-L64】

## 7. Explorar el frente de Pareto

Para visualizar cómo responden las palancas del plan ante pequeñas variaciones, ejecuta el subcomando `pareto` y abre el informe HTML generado:

```bash
tnfr-lfs pareto stint.jsonl --car-model FZR --radius 2 --export html_ext > pareto.html
```

El comando barre el espacio de decisión alrededor del vector actual y produce un frente de Pareto con puntuaciones y desgloses por métrica; el exportador `html_ext` incrusta las tablas directamente en el informe.【F:tnfr_lfs/cli/pareto.py†L23-L117】【F:tnfr_lfs/exporters/report_extended.py†L188-L220】【F:tnfr_lfs/exporters/report_extended.py†L290-L324】 Usa estas filas para contrastar el impacto relativo de cada parámetro antes de aceptar cambios mayores y documenta la elección con las notas del playbook.【F:tnfr_lfs/io/playbook.py†L35-L64】

## 8. Ejecutar A/B testing

Cuando dispongas de dos stints comparables, ejecuta un análisis A/B por vuelta para cuantificar qué variante mejora la métrica objetivo:

```bash
tnfr-lfs compare baseline.jsonl variante.jsonl --metric sense_index --export html_ext > abtest.html
```

La salida HTML resume medias por stint, distribuciones por vuelta y mensajes contextualizados de la sesión. Esto permite detectar de un vistazo si la variante logra mayor `Si` o menor ΔNFR antes de consolidar el cambio en el playbook.【F:tnfr_lfs/cli/compare.py†L28-L135】【F:tnfr_lfs/exporters/report_extended.py†L260-L315】【F:tnfr_lfs/exporters/report_extended.py†L290-L324】 Complementa el análisis con las recomendaciones priorizadas para cada métrica en la tabla de operadores y en el playbook TNFR.【F:tnfr_lfs/io/playbook.py†L35-L64】

## Python API quick start

Each step of the CLI flow is also exposed through the Python API:

```python
from tnfr_lfs.acquisition import OutSimClient
from tnfr_lfs.core.epi import EPIExtractor
from tnfr_lfs.core.segmentation import segment_microsectors
from tnfr_lfs.recommender import RecommendationEngine, SetupPlanner
from tnfr_lfs.exporters.setup_plan import SetupPlan, SetupChange

records = OutSimClient().ingest("stint.csv")
extractor = EPIExtractor()
bundles = extractor.extract(records)
microsectors = segment_microsectors(records, bundles)

engine = RecommendationEngine()
recommendations = engine.generate(bundles)

planner = SetupPlanner()
plan = planner.plan(bundles, microsectors=microsectors, car_model="FZR")

setup_payload = {
    "setup_plan": SetupPlan(
        car_model="FZR",
        session="FP1",
        changes=[
            SetupChange(
                parameter="rear_wing_angle",
                delta=-1.0,
                rationale=recommendations[0].rationale,
                expected_effect=recommendations[0].expected_effect,
            )
        ],
        rationales=[rec.rationale for rec in recommendations],
        expected_effects=[rec.expected_effect for rec in recommendations],
        sensitivities=plan.sensitivities,
        phase_sensitivities=plan.phase_sensitivities,
    )
}
```

The snippet captures telemetry from a CSV file, extracts EPI bundles,
derives microsectors, and combines optimisation with explainable
recommendations to build a setup plan ready for export.  The
``sensitivities`` and ``phase_sensitivities`` mappings expose the
empirical Jacobian gathered during the optimisation, enabling
downstream tooling to reuse the ΔSi/Δp and Δ∫|ΔNFR|/Δp gradients.
